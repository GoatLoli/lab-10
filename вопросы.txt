1. За счет каких средств языка С++ получается изменять длину массива std::vector?

1) push_back() добавляет новый элемент в конец вектора, увеличивая его размер

2) pop_back() удаляет последний элемент из вектора, уменьшая его размер

3) resize() изменяет размер вектора, добавляя новые элементы, если новый размер больше текущего, или удаляя лишние элементы, если новый размер меньше текущего

4) assign() позволяет присвоить вектору новое содержимое, изменяя его размер при необходимости



2. Что такое capacity и чем оно отличается от size? Что делает shrink_to_fit, resize, reserve?

1) capacity - размер выделенной памяти для вектора. Обычно <= размеру вектора (size), поскольку вектор может выделять больше памяти, чем он фактически использует, для избежания повторного выделения памяти

2) size - фактическое количество элементов в векторе

3) shrink_to_fit() - пытается освободить неиспользуемую память, уменьшая capacity до size

4) resize() - изменяет размер вектора на заданное количество элементов. Если новый размер > текущего, новые элементы будут добавлены с нулевым значением. Если новый размер < текущего, лишние элементы будут удалены

5) reserve() - резервирует память для указанного количества элементов, не изменяя их фактического количества. Помогает избежать повторных выделений памяти при добавлении элементов в вектор, если известен приблизительный размер, который он будет иметь



3. Что обозначают знаки < и > при создании std::vector?

1) знаки < и > используются для указания типа данных, который будет храниться в структуре данных std::vector



5. В чем отличие функции at и []? И почему в С++ сделали именно так?

1) функция at() и оператор [] оба предназначены для доступа к элементам вектора или другим контейнерам

1.1) оператор [] возвращает ссылку на элемент по его индексу, но не производит проверку выхода за границы вектора. если использовать [] для доступа к элементу за пределами диапазона вектора, он может вызвать неопределенное поведение программы

1.2) функция at() также возвращает ссылку на элемент по индексу, но выполняет проверку выхода за границы вектора. если индекс находится вне допустимого диапазона, генерирует исключение std::out_of_range